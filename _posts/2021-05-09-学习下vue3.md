---
layout: mypost
title: 学习下Vue 3
categories: [前端]
---

响应式数据由`Object.defineProperty`实现变成了`Proxy`实现。可以不用再担心改了属性没触发改变，注意 IE 不支持 Proxy

据说 Vue3 会在不再支持 IE 11，Vue2 是支持的，后续会把 Vue3 的一些写法更新到 Vue2 中

打包后的体积变小

TypeScript 支持

## 全局 API 变化

项目初始化可以看到，好处是避免了全局改变 Vue 的行为，方便测试，同时也能防止一个页面上初始化多个 Vue 应用时多个应用之间改变全局 API 后可能的干扰

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

new Vue({
  router: new VueRouter({ routes }),
  render: h => h(App)
}).$mount('#app')
```

```js
import { createApp } from 'vue'
import { createRouter } from 'vue-router'
createApp(App).use(createRouter({ routes })).mount('#app')
```

| 2.x 全局 API               | 3.x 实例 API(createApp)     |
| -------------------------- | --------------------------- |
| Vue.config                 | app.config                  |
| Vue.config.productionTip   | 移除                        |
| Vue.config.ignoredElements | app.config.isCustomElement  |
| Vue.component              | app.component               |
| Vue.directive              | app.directive               |
| Vue.mixin                  | app.mixin                   |
| Vue.use                    | app.use                     |
| Vue.prototype              | app.config.globalProperties |

## v-model 变化

2.0 中自定义组件实现 v-mdoel 功能

```
model: { // 自定义名称,默认可省略
  prop: "value",
  event: "input",
},
props: ["value"]
this.$emit("input", value)
```

3.0 中，v-bind 的 `.sync` 修饰符和组件的 `model` 选项已移除

通过对 v-model 的扩展同时可以实现二者的功能，`v-model:xxx` 可定义多个，对应的是`props: ["xxx"]`和`this.$emit("update:xxx", value)`，默认为`modelValue`

少了个概念，又和`v-bind:xxx`

## v-for 中的 Ref 数组

交给组件自己去控制

```
<div v-for="item in list" :ref="setItemRef"></div>

data() {
  return {
    itemRefs: []
  }
}

beforeUpdate() {
  this.itemRefs = []
}

setItemRef(el) {
  if (el) {
    this.itemRefs.push(el)
  }
}
```

## 异步组件更改

之前在在 vue-router 里面用的比较多

```
const asyncPage = () => import('./NextPage.vue')
```

在 Vue 3 中，由于函数式组件被定义为纯函数，因此异步组件的定义需要通过将其包裹在新的 defineAsyncComponent 助手方法中来显式地定义

```
import { defineAsyncComponent } from 'vue'
const asyncPage = defineAsyncComponent(() => import('./NextPage.vue'))
```




## 一些无需了解功能更改

- `<template v-for>` 和非 v-for 节点上 key 用法已更改

  正常写就行，lint 也会提示

- 在同一元素上使用的 v-if 和 v-for 优先级已更改

- v-bind="object" 现在排序敏感

- v-on:event.native 修饰符已移除

- 移除函数式组件

  没用过~

## 组件的改变

Vue3 组件写法只是新增了 setup 函数，和 Vue2 的语法是完全兼容的

组件不在要求只能有一个根组件

## setup

执行顺序 `setup -> beforeCreate -> created`

从执行顺序猜测 setup 和原有的写法是可以共存的，二者可以同时使用，在 setup 执行完成后会把返回的内容和原始写法的内容放到同一级

由于在执行 setup 时尚未创建组件实例, 所以里面无法使用 this（dev 环境可以通过 getCurrentInstance 拿到），同时这样便于把 setup 里面的逻辑抽取出去，多个组件公用。虽然有办法可以在 setup 中拿到组件实例，但是最好还是不要在 setup 中操作组件其他的数据

通过 return 把内容暴露出去, 注意必须返回一个普通的对象，不要返回基本数据类型和响应式对象，另外也可以返回一个 VNode 的 render 函数

```vue
<template>
  <div>
    <div>{{ data2.num }}</div>
    <button @click="incNum">INC</button>
  </div>
</template>

<script>
import { reactive } from 'vue'
export default {
  setup() {
    const data2 = reactive({ num: 10 })
    const incNum = () => data2.num++
    return {
      data2,
      incNum
    }
  }
}
</script>
```

```vue
<script>
import { h, ref } from 'vue'

export default {
  setup() {
    const num = ref(0)
    const incNum = () => num.value++
    return () =>
      h(
        'div',
        {
          onClick: incNum
        },
        [num.value]
      )
  }
}
</script>
```

setup 的参数

```js
export default {
  // ctx:
  //    attrs: Proxy
  //    emit: (event, ...args) => instance.emit(event, ...args)
  //    expose: exposed => {…}
  //    props: Proxy
  //    slots: Proxy
  setup(props, ctx) {}
}
```

另外可以在 setup 中使用下面的 hook 函数，这样 setup 里面就有了整个的生命周期的支持，整个组件中只定义一个 setup 函数就足够了

| life cycle      | hook life cycle   |
| --------------- | ----------------- |
| beforeCreate    | not needed        |
| created         | not needed        |
| beforeMount     | onBeforeMount     |
| mounted         | onMounted         |
| beforeUpdate    | onBeforeUpdate    |
| updated         | onUpdated         |
| beforeUnmount   | onBeforeUnmount   |
| unmounted       | onUnmounted       |
| errorCaptured   | onErrorCaptured   |
| renderTracked   | onRenderTracked   |
| renderTriggered | onRenderTriggered |

## composition API

使用传统的 option 配置方法写组件的时候问题，随着业务复杂度越来越高，代码量会不断的加大；由于相关业务的代码需要遵循 option 的配置写到特定的区域，导致后续维护非常的复杂，同时代码可复用性不高，而 composition API 就是为了解决这个问题而生的

```js
import { ref } from 'vue'
```

使用 ref 创建一个响应式变量，因为只有对象才能被代理，所以为了实现响应式其实把他内容包装为了对象的 value 属性中

```js
const counter = ref(0)
console.log(counter) // { value: 0 }
console.log(counter.value) // 0
```

当 ref 作为渲染上下文 (从 setup() 中返回的对象) 上的 property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加 `.value`

当 ref 作为响应式对象的 property 被访问或更改时，为使其行为类似于普通 property，它会自动展开内部值：

```js
const count = ref(0)
const state = reactive({
  count
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

使用 readonly 防止更改响应式对象

reactive 相当于 Vue 2.x 中的 `Vue.observable()` API ，为避免与 RxJS 中的 observables 混淆因此对其重命名。

```js
import { reactive } from 'vue'

// 创建响应式对象
// 参数必须是一个对象，不能是基本数据类型
const data = reactive({ num: 10 })
```

## 事件触发 setup 返回的函数

函数里的 this 是 setup 的返回值

## setup 中绑定 $ref

setup 里面是没有 this 的所以没法拿到绑定到$ref 上的 DOM，要通过`ref`函数创建的响应数据进行绑定。

`ref`用于创建一个包装式的响应对象，含有一个响应式属性 value，在模板中读的时候可以省略`.value`，在 setup 中读写的时候记得加上`.value`。是对`reactive`的一种包装

弥补了`reactive`不能是基本数据类型的问题

`ref`可以嵌套在`reactive`中

```js
// <input type="text" v-model="data2.text" ref="$input" />
import { ref } from 'vue'

setup() {
  const $input = ref()
  return {
    $input
  }
}

```

v-for 绑定 refs

```
<template>
  <div v-for="(item, i) in list" :ref="el => { if (el) divs[i] = el }">
    {{ item }}
  </div>
</template>

<script>
  import { ref, reactive, onBeforeUpdate } from 'vue'

  export default {
    setup() {
      const list = reactive([1, 2, 3])
      const divs = ref([])

      // 确保在每次更新之前重置ref
      onBeforeUpdate(() => {
        divs.value = []
      })

      return {
        list,
        divs
      }
    }
  }
</script>
```

## toRefs

响应式对象解构后，响应式特性丢失，此时需要`toRefs`将响应式对象转化为 key(string), value(ref) 格式的对象，这样解构后每一项都是可响应的

```js
setup() {
  const state = reactive({ count: 0 })

  const onClick = function() {
    console.log(state.count++)
  }
  return {
    // ...state,      // {{count}} 丢失响应性
    ...toRefs(state), // {{count}} 响应
    state,            // {{state.count}} 响应
    onClick
  }
},
```

## 好处

抽取组件之间的逻辑

甚至可以写出 ReactHooks 风格的代码

```js
function useCount() {
  const count = ref(0)
  const incCount = function() {
    count.value++
  }
  return {
    count,
    incCount
  }
}

setup() {
  const { count, incCount } = useCount()

  return {
    count,
    incCount
  }
}
```

## 父子组件通信：向下

没啥变化，setup 中没有 this，但是函数的第一个参数就是 props

```js
export default {
  props: ['age'],
  setup(props) {
    // props 是只读的，无法在setup中修改
  }
}
```

## 父子组件通信：向上

setup 中没有 this，所以`this.$emit`是没有的，同样可以在参数中获取 emit

```js
export default {
  setup(props, { emit }) {}
}
```

## 使用 readonly 防止更改响应式对象

props 应该就是通过这个修饰过的

```js
import { reactive, readonly } from 'vue'

const original = reactive({ count: 0 })

const copy = readonly(original)

// 在copy上转换original 会触发侦听器依赖

original.count++

// 转换copy 将导失败并导致警告
copy.count++ // 警告: "Set operation on key 'count' failed: target is readonly."
```

与 watchEffect 比较，watch 允许我们：

懒执行副作用；
更具体地说明什么状态应该触发侦听器重新运行；
访问侦听状态变化前后的值。 #侦听单个数据源

```js
watch(ref,(newValue，newValue)=>{}) // ok
watch(reactive,(newValue，newValue)=>{}) // 值改变时触发，属性改变触发，由于引用，新旧值相同
watch(reactive.key,(newValue，newValue)=>{}) // 无效
```

正确的写法如下

```js
watch(()=>ref.value,(newValue，newValue)=>{}) // ok
watch(()=>reactive.key,(newValue，newValue)=>{}) // ok
```

## vue-router

this.$router => useRouter()

this.$route => useRoute()

## vuex

this.$store => useStore()

## 参考

[Vue3 的响应式和以前有什么区别，Proxy 无敌？](https://juejin.cn/post/6844904122479542285)

[Vue3 中文文档](https://v3.cn.vuejs.org/guide/introduction.html)

[v3 迁移指南](https://v3.cn.vuejs.org/guide/migration/introduction.html)
